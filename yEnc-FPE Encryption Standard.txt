RFC-DRAFT: yEnc-FPE Encryption Standard
Version: 0.1
Date: 2025-10-22
Author: Independent Specification

Status: Experimental
Category: Informational

Abstract:
This document defines a reversible, format-preserving encryption scheme
for yEnc-encoded binary blocks used in Usenet transfers. The scheme
maintains exact length (±1 byte for sentinel) and preserves the printable
character range required by yEnc. It specifies normalization, encryption
using AES-FF1, and deterministic reconstruction of yEnc headers, bodies,
and footers.

----------------------------------------------------------------------
1. Scope

This specification describes the "yEnc-FPE" method to encrypt and decrypt
full yEnc message blocks while maintaining:
  - yEnc-compatible printable characters
  - deterministic reconstruction of the original yEnc structure
  - fixed ciphertext length equal to plaintext length (+1 sentinel byte)
  - format-preserving output suitable for Usenet transmission
  - no additional yEnc encoding step required after encryption

It is intended for use in multipart binary uploads or segment encryption,
where each part must remain a valid yEnc-encoded text that can be
transmitted directly without further encoding.

----------------------------------------------------------------------
2. Definitions

  yEnc Block:
    A text segment beginning with "=ybegin" and ending with "=yend".

  Header:
    The region from "=ybegin" through the final header line before the
    first data line.

  Body:
    The encoded data between the end of the header and the "=yend"
    footer.

  Footer:
    The "=yend" line and any subsequent line terminators.

  Sentinel:
    The single-byte marker 0xFF inserted between header and body prior
    to encryption.

  Alphabet:
    The 253-symbol byte domain: all byte values 0x01–0xFF except 0x0A
    (LF) and 0x0D (CR).

  segmentIndex:
    A 32-bit unsigned integer >= 1 providing a continuous, globally
    unique index across all segments in the upload sequence,
    regardless of file boundaries. For example, if file 1 has
    segments 1, 2, and 3, then the segment 1 of file 2 has
    segmentIndex 4. This ensures unique tweak values for every
    segment across the entire upload session.

----------------------------------------------------------------------
3. Normalization Procedure (Encryption Preprocessing)

Input: Complete yEnc block with CRLF line endings.

Steps:

1. Remove all carriage return (CR, 0x0D) characters.
2. Identify the yEnc header section (from "=ybegin" to the line
   preceding the first data line).
3. Replace the single line break that separates the header from the
   first data line with the sentinel byte 0xFF.
4. Remove all other newline (LF) characters within the body and the
   header.
5. Remove newline characters between body and footer.
6. Concatenate:
     headerText + 0xFF + bodyText + footerText
   Resulting normalized plaintext is free of CR/LF and fits the 253-
   character alphabet.

This representation preserves the header–body boundary and allows
deterministic reconstruction of yEnc formatting.

----------------------------------------------------------------------
4. Encryption Algorithm

Algorithm: AES-FF1 (NIST SP 800-38G compliant Format-Preserving
Encryption)

Parameters:
  - Alphabet: 253 printable characters (see Section 2)
  - Block cipher: AES-256
  - Key derivation: Argon2id(password, salt)
  - Tweak: HMAC-SHA256(master, "ff1/tweak" || segmentIndex)[0:8]
  - Salt: 16 random bytes from the same alphabet (0x01–0xFF excluding
    CR/LF)
  - Line length: user-configurable (default 128)

Procedure:

  a. Derive masterKey = Argon2id(password, salt)
  b. Derive encKey = HMAC-SHA256(masterKey, "ff1/enc-key")
  c. Derive tweak as specified above.
  d. Encrypt normalized plaintext using FF1 over the 253-character
     alphabet.
  e. Prepend the salt to the ciphertext.
  f. Insert CRLF (0x0D 0x0A) line breaks for visual formatting after every
     `lineLen` characters (default 128). Line breaks are not part of the
     cryptographic data.

The ciphertext is now ASCII-safe and yEnc-compatible, requiring no
additional yEnc encoding step before transmission.

----------------------------------------------------------------------
5. Decryption Algorithm

Input: Ciphertext as produced above.

Steps:

1. Remove all carriage returns (CR) and line breaks (LF).
2. Extract the first 16 bytes as salt.
3. Derive masterKey, encKey, and tweak identically to encryption.
4. Apply AES-FF1 decryption over the 253-character alphabet.
5. Obtain the normalized plaintext (header + 0xFF + body + footer).

----------------------------------------------------------------------
6. Denormalization Procedure (Postprocessing)

Input: normalized plaintext.

Steps:

1. Split at the first occurrence of the sentinel 0xFF.
   - Left part: headerText
   - Right part: body+footer
2. Identify the footer by searching for "=yend".
3. Extract the "line=" value from the header; if missing, default to 128.
4. Reconstruct:
     a. Insert CRLF between header lines if "=ypart" is present.
     b. Insert CRLF after headerText.
     c. Insert line breaks into the body every N characters (where N =
        line value), **but never between an escape marker (‘=’) and its
        following byte.**
        If a line boundary falls immediately after an '=', move the
        boundary forward by one byte so that the escape sequence remains
        intact.
     d. Ensure one CRLF precedes "=yend".
     e. Append final CRLF if absent.

The resulting text is a syntactically correct yEnc block equivalent to
the original.

----------------------------------------------------------------------
7. Length Properties

- The normalized plaintext is exactly one byte longer than the original
  without line breaks (due to sentinel insertion).
- Ciphertext length equals normalized plaintext length.
- When displayed with formatting line breaks (LF after every X chars),
  the on-wire representation is longer by (len / X) bytes.

----------------------------------------------------------------------
8. Security Considerations

- AES-FF1 provides confidentiality equivalent to AES-256 under unique
  key/tweak pairs.
- The tweak ensures uniqueness per segmentIndex across all files.
- Argon2id mitigates password brute-force; constant salt weakens
  resistance to precomputation.
- The scheme offers confidentiality only, not integrity or authenticity.
- Deterministic output leaks identical plaintext segments if key/tweak
  pairs repeat.

----------------------------------------------------------------------
9. Interoperability Notes

- Any FF1 implementation conforming to NIST SP 800-38G may be used if it
  supports custom alphabets.
- Implementations must ensure 1:1 reversible mapping between byte values
  and alphabet symbols.
- yEnc parsers consuming the decrypted output must handle standard CRLF
  endings.

----------------------------------------------------------------------
10. Example

Input plaintext:

  =ybegin line=128 size=18 name=file.bin\r\n
  abcDEF123\r\n
  =yend size=18\r\n

Normalized:

  =ybegin line=128 size=18 name=file.bin<0xFF>abcDEF123=yend size=18

Ciphertext (hex-encoded illustration, actual output FF1-mapped):

  <16-byte salt><encrypted 253-symbol sequence>

After decryption and denormalization, the reconstructed text matches the
original yEnc block byte-for-byte.

----------------------------------------------------------------------
11. Summary

yEnc-FPE combines deterministic format-preserving encryption (AES-FF1)
with yEnc-specific normalization, producing ciphertext that:
  - Remains printable and safe for Usenet transport.
  - Preserves message length.
  - Allows perfect structural reconstruction.
  - Requires no additional yEnc encoding after encryption.

This eliminates the need for a separate encoding step, as the encrypted
output is already yEnc-compatible and ready for direct transmission.

This draft defines the canonical processing rules for interoperability
between implementations.

----------------------------------------------------------------------
End of Document